-- | Generated by __protobuf__ from file `google/protobuf/struct.proto`
module Google.Protobuf.Struct
( Struct(..), StructRow, StructR, parseStruct, putStruct, defaultStruct, mkStruct, mergeStruct
, Struct_FieldsEntry(..), Struct_FieldsEntryRow, Struct_FieldsEntryR, parseStruct_FieldsEntry, putStruct_FieldsEntry, defaultStruct_FieldsEntry, mkStruct_FieldsEntry, mergeStruct_FieldsEntry
, Value(..), ValueRow, ValueR, parseValue, putValue, defaultValue, mkValue, mergeValue, Value_Kind(..)
, ListValue(..), ListValueRow, ListValueR, parseListValue, putListValue, defaultListValue, mkListValue, mergeListValue
, NullValue(..)
)
where
import Protobuf.Internal.Prelude
import Protobuf.Internal.Prelude as Prelude




-- | Message generated by __protobuf__ from `google.protobuf.Struct`
-- | 
-- | `Struct` represents a structured data value, consisting of fields
-- | which map to dynamically typed values. In some languages, `Struct`
-- | might be supported by a native representation. For example, in
-- | scripting languages like JS a struct is represented as an
-- | object. The details of that representation are described together
-- | with the proto support for the language.
-- | 
-- | The JSON representation for `Struct` is JSON object.
newtype Struct = Struct StructR
type StructRow =
  ( fields :: Array Struct_FieldsEntry
  , __unknown_fields :: Array Prelude.UnknownField
  )
type StructR = Record StructRow
derive instance genericStruct :: Prelude.Generic Struct _
derive instance newtypeStruct :: Prelude.Newtype Struct _
derive instance eqStruct :: Prelude.Eq Struct
instance showStruct :: Prelude.Show Struct where show x = Prelude.genericShow x

putStruct :: forall m. Prelude.MonadEffect m => Prelude.MonadRec m => Struct -> Prelude.PutM m Prelude.Unit
putStruct (Struct r) = do
  Prelude.putRepeated 1 r.fields $ Prelude.putLenDel putStruct_FieldsEntry
  Prelude.foldRecM (\_ x -> Prelude.putFieldUnknown x) unit r.__unknown_fields

parseStruct :: forall m. Prelude.MonadEffect m => Prelude.MonadRec m => Prelude.ByteLength -> Prelude.ParserT Prelude.DataView m Struct
parseStruct length = Prelude.label "Struct / " $
  Prelude.parseMessage Struct defaultStruct parseField length
 where
  parseField
    :: Prelude.FieldNumberInt
    -> Prelude.WireType
    -> Prelude.ParserT Prelude.DataView m (Prelude.Builder StructR StructR)
  parseField 1 Prelude.LenDel = Prelude.label "fields / " $ do
    x <- Prelude.parseLenDel parseStruct_FieldsEntry
    pure $ Prelude.modify (Prelude.Proxy :: Prelude.Proxy "fields") $ Prelude.flip Prelude.snoc x
  parseField fieldNumber wireType = Prelude.parseFieldUnknown fieldNumber wireType

defaultStruct :: StructR
defaultStruct =
  { fields: []
  , __unknown_fields: []
  }

mkStruct :: forall r1 r3. Prelude.Union r1 StructRow r3 => Prelude.Nub r3 StructRow => Record r1 -> Struct
mkStruct r = Struct $ Prelude.merge r defaultStruct

mergeStruct :: Struct -> Struct -> Struct
mergeStruct (Struct l) (Struct r) = Struct
  { fields: r.fields <> l.fields
  , __unknown_fields: r.__unknown_fields <> l.__unknown_fields
  }


-- | Message generated by __protobuf__ from `google.protobuf.Struct.FieldsEntry`
newtype Struct_FieldsEntry = Struct_FieldsEntry Struct_FieldsEntryR
type Struct_FieldsEntryRow =
  ( key :: Prelude.Maybe String
  , value :: Prelude.Maybe Value
  , __unknown_fields :: Array Prelude.UnknownField
  )
type Struct_FieldsEntryR = Record Struct_FieldsEntryRow
derive instance genericStruct_FieldsEntry :: Prelude.Generic Struct_FieldsEntry _
derive instance newtypeStruct_FieldsEntry :: Prelude.Newtype Struct_FieldsEntry _
derive instance eqStruct_FieldsEntry :: Prelude.Eq Struct_FieldsEntry
instance showStruct_FieldsEntry :: Prelude.Show Struct_FieldsEntry where show x = Prelude.genericShow x

putStruct_FieldsEntry :: forall m. Prelude.MonadEffect m => Prelude.MonadRec m => Struct_FieldsEntry -> Prelude.PutM m Prelude.Unit
putStruct_FieldsEntry (Struct_FieldsEntry r) = do
  Prelude.putOptional 1 r.key Prelude.isDefault Prelude.encodeStringField
  Prelude.putOptional 2 r.value (\_ -> false) $ Prelude.putLenDel putValue
  Prelude.foldRecM (\_ x -> Prelude.putFieldUnknown x) unit r.__unknown_fields

parseStruct_FieldsEntry :: forall m. Prelude.MonadEffect m => Prelude.MonadRec m => Prelude.ByteLength -> Prelude.ParserT Prelude.DataView m Struct_FieldsEntry
parseStruct_FieldsEntry length = Prelude.label "FieldsEntry / " $
  Prelude.parseMessage Struct_FieldsEntry defaultStruct_FieldsEntry parseField length
 where
  parseField
    :: Prelude.FieldNumberInt
    -> Prelude.WireType
    -> Prelude.ParserT Prelude.DataView m (Prelude.Builder Struct_FieldsEntryR Struct_FieldsEntryR)
  parseField 1 Prelude.LenDel = Prelude.label "key / " $ do
    x <- Prelude.decodeString
    pure $ Prelude.modify (Prelude.Proxy :: Prelude.Proxy "key") $ \_ -> Prelude.Just x
  parseField 2 Prelude.LenDel = Prelude.label "value / " $ do
    x <- Prelude.parseLenDel parseValue
    pure $ Prelude.modify (Prelude.Proxy :: Prelude.Proxy "value") $ Prelude.Just Prelude.<<< Prelude.maybe x (mergeValue x)
  parseField fieldNumber wireType = Prelude.parseFieldUnknown fieldNumber wireType

defaultStruct_FieldsEntry :: Struct_FieldsEntryR
defaultStruct_FieldsEntry =
  { key: Prelude.Nothing
  , value: Prelude.Nothing
  , __unknown_fields: []
  }

mkStruct_FieldsEntry :: forall r1 r3. Prelude.Union r1 Struct_FieldsEntryRow r3 => Prelude.Nub r3 Struct_FieldsEntryRow => Record r1 -> Struct_FieldsEntry
mkStruct_FieldsEntry r = Struct_FieldsEntry $ Prelude.merge r defaultStruct_FieldsEntry

mergeStruct_FieldsEntry :: Struct_FieldsEntry -> Struct_FieldsEntry -> Struct_FieldsEntry
mergeStruct_FieldsEntry (Struct_FieldsEntry l) (Struct_FieldsEntry r) = Struct_FieldsEntry
  { key: Prelude.alt l.key r.key
  , value: Prelude.mergeWith mergeValue l.value r.value
  , __unknown_fields: r.__unknown_fields <> l.__unknown_fields
  }


-- | Message generated by __protobuf__ from `google.protobuf.Value`
-- | 
-- | `Value` represents a dynamically typed value which can be either
-- | null, a number, a string, a boolean, a recursive struct value, or a
-- | list of values. A producer of value is expected to set one of these
-- | variants. Absence of any variant indicates an error.
-- | 
-- | The JSON representation for `Value` is JSON value.
newtype Value = Value ValueR
type ValueRow =
  ( kind :: Prelude.Maybe Value_Kind
  , __unknown_fields :: Array Prelude.UnknownField
  )
type ValueR = Record ValueRow
derive instance genericValue :: Prelude.Generic Value _
derive instance newtypeValue :: Prelude.Newtype Value _
derive instance eqValue :: Prelude.Eq Value
instance showValue :: Prelude.Show Value where show x = Prelude.genericShow x

putValue :: forall m. Prelude.MonadEffect m => Prelude.MonadRec m => Value -> Prelude.PutM m Prelude.Unit
putValue (Value r) = do
  case r.kind of
    Prelude.Nothing -> pure Prelude.unit
    Prelude.Just (Value_Kind_Null_value x) -> Prelude.putOptional 1 (Prelude.Just x) (\_ -> false) Prelude.putEnumField
    Prelude.Just (Value_Kind_Number_value x) -> Prelude.putOptional 2 (Prelude.Just x) (\_ -> false) Prelude.encodeDoubleField
    Prelude.Just (Value_Kind_String_value x) -> Prelude.putOptional 3 (Prelude.Just x) (\_ -> false) Prelude.encodeStringField
    Prelude.Just (Value_Kind_Bool_value x) -> Prelude.putOptional 4 (Prelude.Just x) (\_ -> false) Prelude.encodeBoolField
    Prelude.Just (Value_Kind_Struct_value x) -> Prelude.putOptional 5 (Prelude.Just x) (\_ -> false) $ Prelude.putLenDel putStruct
    Prelude.Just (Value_Kind_List_value x) -> Prelude.putOptional 6 (Prelude.Just x) (\_ -> false) $ Prelude.putLenDel putListValue
  Prelude.foldRecM (\_ x -> Prelude.putFieldUnknown x) unit r.__unknown_fields

parseValue :: forall m. Prelude.MonadEffect m => Prelude.MonadRec m => Prelude.ByteLength -> Prelude.ParserT Prelude.DataView m Value
parseValue length = Prelude.label "Value / " $
  Prelude.parseMessage Value defaultValue parseField length
 where
  parseField
    :: Prelude.FieldNumberInt
    -> Prelude.WireType
    -> Prelude.ParserT Prelude.DataView m (Prelude.Builder ValueR ValueR)
  parseField 1 Prelude.VarInt = Prelude.label "null_value / " $ do
    x <- Prelude.parseEnum
    pure $ Prelude.modify (Prelude.Proxy :: Prelude.Proxy "kind") $ \_ -> Prelude.Just (Value_Kind_Null_value x)
  parseField 2 Prelude.Bits64 = Prelude.label "number_value / " $ do
    x <- Prelude.decodeDouble
    pure $ Prelude.modify (Prelude.Proxy :: Prelude.Proxy "kind") $ \_ -> Prelude.Just (Value_Kind_Number_value x)
  parseField 3 Prelude.LenDel = Prelude.label "string_value / " $ do
    x <- Prelude.decodeString
    pure $ Prelude.modify (Prelude.Proxy :: Prelude.Proxy "kind") $ \_ -> Prelude.Just (Value_Kind_String_value x)
  parseField 4 Prelude.VarInt = Prelude.label "bool_value / " $ do
    x <- Prelude.decodeBool
    pure $ Prelude.modify (Prelude.Proxy :: Prelude.Proxy "kind") $ \_ -> Prelude.Just (Value_Kind_Bool_value x)
  parseField 5 Prelude.LenDel = Prelude.label "struct_value / " $ do
    x <- Prelude.parseLenDel parseStruct
    pure $ Prelude.modify (Prelude.Proxy :: Prelude.Proxy "kind") $ mergeValue_Kind (Prelude.Just (Value_Kind_Struct_value x))
  parseField 6 Prelude.LenDel = Prelude.label "list_value / " $ do
    x <- Prelude.parseLenDel parseListValue
    pure $ Prelude.modify (Prelude.Proxy :: Prelude.Proxy "kind") $ mergeValue_Kind (Prelude.Just (Value_Kind_List_value x))
  parseField fieldNumber wireType = Prelude.parseFieldUnknown fieldNumber wireType

defaultValue :: ValueR
defaultValue =
  { kind: Prelude.Nothing
  , __unknown_fields: []
  }

mkValue :: forall r1 r3. Prelude.Union r1 ValueRow r3 => Prelude.Nub r3 ValueRow => Record r1 -> Value
mkValue r = Value $ Prelude.merge r defaultValue
data Value_Kind
  = Value_Kind_Null_value NullValue
  | Value_Kind_Number_value Number
  | Value_Kind_String_value String
  | Value_Kind_Bool_value Boolean
  | Value_Kind_Struct_value Struct
  | Value_Kind_List_value ListValue

derive instance genericValue_Kind :: Prelude.Generic Value_Kind _
derive instance eqValue_Kind :: Prelude.Eq Value_Kind
instance showValue_Kind :: Prelude.Show Value_Kind where show = Prelude.genericShow

mergeValue_Kind :: Prelude.Maybe Value_Kind -> Prelude.Maybe Value_Kind -> Prelude.Maybe Value_Kind
mergeValue_Kind l r = case Prelude.Tuple l r of
  Prelude.Tuple (Prelude.Just (Value_Kind_Struct_value l')) (Prelude.Just (Value_Kind_Struct_value r')) -> Prelude.map Value_Kind_Struct_value $ Prelude.mergeWith mergeStruct (Prelude.Just l') (Prelude.Just r')
  Prelude.Tuple (Prelude.Just (Value_Kind_List_value l')) (Prelude.Just (Value_Kind_List_value r')) -> Prelude.map Value_Kind_List_value $ Prelude.mergeWith mergeListValue (Prelude.Just l') (Prelude.Just r')
  _ -> Prelude.alt l r

mergeValue :: Value -> Value -> Value
mergeValue (Value l) (Value r) = Value
  { kind: mergeValue_Kind l.kind r.kind
  , __unknown_fields: r.__unknown_fields <> l.__unknown_fields
  }


-- | Message generated by __protobuf__ from `google.protobuf.ListValue`
-- | 
-- | `ListValue` is a wrapper around a repeated field of values.
-- | 
-- | The JSON representation for `ListValue` is JSON array.
newtype ListValue = ListValue ListValueR
type ListValueRow =
  ( values :: Array Value
  , __unknown_fields :: Array Prelude.UnknownField
  )
type ListValueR = Record ListValueRow
derive instance genericListValue :: Prelude.Generic ListValue _
derive instance newtypeListValue :: Prelude.Newtype ListValue _
derive instance eqListValue :: Prelude.Eq ListValue
instance showListValue :: Prelude.Show ListValue where show x = Prelude.genericShow x

putListValue :: forall m. Prelude.MonadEffect m => Prelude.MonadRec m => ListValue -> Prelude.PutM m Prelude.Unit
putListValue (ListValue r) = do
  Prelude.putRepeated 1 r.values $ Prelude.putLenDel putValue
  Prelude.foldRecM (\_ x -> Prelude.putFieldUnknown x) unit r.__unknown_fields

parseListValue :: forall m. Prelude.MonadEffect m => Prelude.MonadRec m => Prelude.ByteLength -> Prelude.ParserT Prelude.DataView m ListValue
parseListValue length = Prelude.label "ListValue / " $
  Prelude.parseMessage ListValue defaultListValue parseField length
 where
  parseField
    :: Prelude.FieldNumberInt
    -> Prelude.WireType
    -> Prelude.ParserT Prelude.DataView m (Prelude.Builder ListValueR ListValueR)
  parseField 1 Prelude.LenDel = Prelude.label "values / " $ do
    x <- Prelude.parseLenDel parseValue
    pure $ Prelude.modify (Prelude.Proxy :: Prelude.Proxy "values") $ Prelude.flip Prelude.snoc x
  parseField fieldNumber wireType = Prelude.parseFieldUnknown fieldNumber wireType

defaultListValue :: ListValueR
defaultListValue =
  { values: []
  , __unknown_fields: []
  }

mkListValue :: forall r1 r3. Prelude.Union r1 ListValueRow r3 => Prelude.Nub r3 ListValueRow => Record r1 -> ListValue
mkListValue r = ListValue $ Prelude.merge r defaultListValue

mergeListValue :: ListValue -> ListValue -> ListValue
mergeListValue (ListValue l) (ListValue r) = ListValue
  { values: r.values <> l.values
  , __unknown_fields: r.__unknown_fields <> l.__unknown_fields
  }


-- | Enum generated by __protobuf__ from `google.protobuf.NullValue`
-- | 
-- | `NullValue` is a singleton enumeration to represent the null value for the
-- | `Value` type union.
-- | 
-- | The JSON representation for `NullValue` is JSON `null`.
data NullValue
  = NullValue_NULL_VALUE
derive instance genericNullValue :: Prelude.Generic NullValue _
derive instance eqNullValue :: Prelude.Eq NullValue
instance showNullValue :: Prelude.Show NullValue where show = Prelude.genericShow
instance ordNullValue :: Prelude.Ord NullValue where compare = Prelude.genericCompare
instance boundedNullValue :: Prelude.Bounded NullValue
 where
  bottom = Prelude.genericBottom
  top = Prelude.genericTop
instance enumNullValue :: Prelude.Enum NullValue
 where
  succ = Prelude.genericSucc
  pred = Prelude.genericPred
instance boundedenumNullValue :: Prelude.BoundedEnum NullValue
 where
  cardinality = Prelude.genericCardinality
  toEnum (0) = Prelude.Just NullValue_NULL_VALUE
  toEnum _ = Prelude.Nothing
  fromEnum NullValue_NULL_VALUE = (0)
instance defaultNullValue :: Prelude.Default NullValue
 where
  default = NullValue_NULL_VALUE
  isDefault = eq NullValue_NULL_VALUE

