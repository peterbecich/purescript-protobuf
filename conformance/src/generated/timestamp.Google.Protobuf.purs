-- | Generated by __protobuf__ from file `google/protobuf/timestamp.proto`
module Google.Protobuf.Timestamp
( Timestamp(..), TimestampRow, TimestampR, parseTimestamp, putTimestamp, defaultTimestamp, mkTimestamp, mergeTimestamp
)
where
import Protobuf.Internal.Prelude
import Protobuf.Internal.Prelude as Prelude




-- | Message generated by __protobuf__ from `google.protobuf.Timestamp`
-- | 
-- | A Timestamp represents a point in time independent of any time zone or local
-- | calendar, encoded as a count of seconds and fractions of seconds at
-- | nanosecond resolution. The count is relative to an epoch at UTC midnight on
-- | January 1, 1970, in the proleptic Gregorian calendar which extends the
-- | Gregorian calendar backwards to year one.
-- | 
-- | All minutes are 60 seconds long. Leap seconds are "smeared" so that no leap
-- | second table is needed for interpretation, using a [24-hour linear
-- | smear](https://developers.google.com/time/smear).
-- | 
-- | The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By
-- | restricting to that range, we ensure that we can convert to and from [RFC
-- | 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.
-- | 
-- | # Examples
-- | 
-- | Example 1: Compute Timestamp from POSIX `time()`.
-- | 
-- |     Timestamp timestamp;
-- |     timestamp.set_seconds(time(NULL));
-- |     timestamp.set_nanos(0);
-- | 
-- | Example 2: Compute Timestamp from POSIX `gettimeofday()`.
-- | 
-- |     struct timeval tv;
-- |     gettimeofday(&tv, NULL);
-- | 
-- |     Timestamp timestamp;
-- |     timestamp.set_seconds(tv.tv_sec);
-- |     timestamp.set_nanos(tv.tv_usec * 1000);
-- | 
-- | Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.
-- | 
-- |     FILETIME ft;
-- |     GetSystemTimeAsFileTime(&ft);
-- |     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;
-- | 
-- |     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
-- |     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
-- |     Timestamp timestamp;
-- |     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
-- |     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));
-- | 
-- | Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.
-- | 
-- |     long millis = System.currentTimeMillis();
-- | 
-- |     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
-- |         .setNanos((int) ((millis % 1000) * 1000000)).build();
-- | 
-- | Example 5: Compute Timestamp from Java `Instant.now()`.
-- | 
-- |     Instant now = Instant.now();
-- | 
-- |     Timestamp timestamp =
-- |         Timestamp.newBuilder().setSeconds(now.getEpochSecond())
-- |             .setNanos(now.getNano()).build();
-- | 
-- | Example 6: Compute Timestamp from current time in Python.
-- | 
-- |     timestamp = Timestamp()
-- |     timestamp.GetCurrentTime()
-- | 
-- | # JSON Mapping
-- | 
-- | In JSON format, the Timestamp type is encoded as a string in the
-- | [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
-- | format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
-- | where {year} is always expressed using four digits while {month}, {day},
-- | {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
-- | seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
-- | are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
-- | is required. A proto3 JSON serializer should always use UTC (as indicated by
-- | "Z") when printing the Timestamp type and a proto3 JSON parser should be
-- | able to accept both UTC and other timezones (as indicated by an offset).
-- | 
-- | For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
-- | 01:30 UTC on January 15, 2017.
-- | 
-- | In JavaScript, one can convert a Date object to this format using the
-- | standard
-- | [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
-- | method. In Python, a standard `datetime.datetime` object can be converted
-- | to this format using
-- | [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with
-- | the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use
-- | the Joda Time's [`ISODateTimeFormat.dateTime()`](
-- | http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()
-- | ) to obtain a formatter capable of generating timestamps in this format.
-- | 
newtype Timestamp = Timestamp TimestampR
type TimestampRow =
  ( seconds :: Prelude.Maybe Prelude.Int64
  , nanos :: Prelude.Maybe Int
  , __unknown_fields :: Array Prelude.UnknownField
  )
type TimestampR = Record TimestampRow
derive instance genericTimestamp :: Prelude.Generic Timestamp _
derive instance newtypeTimestamp :: Prelude.Newtype Timestamp _
derive instance eqTimestamp :: Prelude.Eq Timestamp
instance showTimestamp :: Prelude.Show Timestamp where show x = Prelude.genericShow x

putTimestamp :: forall m. Prelude.MonadEffect m => Prelude.MonadRec m => Timestamp -> Prelude.PutM m Prelude.Unit
putTimestamp (Timestamp r) = do
  Prelude.putOptional 1 r.seconds Prelude.isDefault Prelude.encodeInt64Field
  Prelude.putOptional 2 r.nanos Prelude.isDefault Prelude.encodeInt32Field
  Prelude.foldRecM (\_ x -> Prelude.putFieldUnknown x) unit r.__unknown_fields

parseTimestamp :: forall m. Prelude.MonadEffect m => Prelude.MonadRec m => Prelude.ByteLength -> Prelude.ParserT Prelude.DataView m Timestamp
parseTimestamp length = Prelude.label "Timestamp / " $
  Prelude.parseMessage Timestamp defaultTimestamp parseField length
 where
  parseField
    :: Prelude.FieldNumberInt
    -> Prelude.WireType
    -> Prelude.ParserT Prelude.DataView m (Prelude.Builder TimestampR TimestampR)
  parseField 1 Prelude.VarInt = Prelude.label "seconds / " $ do
    x <- Prelude.decodeInt64
    pure $ Prelude.modify (Prelude.Proxy :: Prelude.Proxy "seconds") $ \_ -> Prelude.Just x
  parseField 2 Prelude.VarInt = Prelude.label "nanos / " $ do
    x <- Prelude.decodeInt32
    pure $ Prelude.modify (Prelude.Proxy :: Prelude.Proxy "nanos") $ \_ -> Prelude.Just x
  parseField fieldNumber wireType = Prelude.parseFieldUnknown fieldNumber wireType

defaultTimestamp :: TimestampR
defaultTimestamp =
  { seconds: Prelude.Nothing
  , nanos: Prelude.Nothing
  , __unknown_fields: []
  }

mkTimestamp :: forall r1 r3. Prelude.Union r1 TimestampRow r3 => Prelude.Nub r3 TimestampRow => Record r1 -> Timestamp
mkTimestamp r = Timestamp $ Prelude.merge r defaultTimestamp

mergeTimestamp :: Timestamp -> Timestamp -> Timestamp
mergeTimestamp (Timestamp l) (Timestamp r) = Timestamp
  { seconds: Prelude.alt l.seconds r.seconds
  , nanos: Prelude.alt l.nanos r.nanos
  , __unknown_fields: r.__unknown_fields <> l.__unknown_fields
  }


